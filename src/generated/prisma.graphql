type AggregateAlert {
  count: Int!
}

type AggregateConversation {
  count: Int!
}

type AggregateText {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Alert {
  id: ID!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  author: User!
}

type AlertConnection {
  pageInfo: PageInfo!
  edges: [AlertEdge]!
  aggregate: AggregateAlert!
}

input AlertCreateInput {
  id: ID
  text: String!
  author: UserCreateOneInput!
}

type AlertEdge {
  node: Alert!
  cursor: String!
}

enum AlertOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AlertPreviousValues {
  id: ID!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AlertSubscriptionPayload {
  mutation: MutationType!
  node: Alert
  updatedFields: [String!]
  previousValues: AlertPreviousValues
}

input AlertSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AlertWhereInput
  AND: [AlertSubscriptionWhereInput!]
  OR: [AlertSubscriptionWhereInput!]
  NOT: [AlertSubscriptionWhereInput!]
}

input AlertUpdateInput {
  text: String
  author: UserUpdateOneRequiredInput
}

input AlertUpdateManyMutationInput {
  text: String
}

input AlertWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  author: UserWhereInput
  AND: [AlertWhereInput!]
  OR: [AlertWhereInput!]
  NOT: [AlertWhereInput!]
}

input AlertWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Conversation {
  id: ID!
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
  texts(where: TextWhereInput, orderBy: TextOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Text!]
  participants(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type ConversationConnection {
  pageInfo: PageInfo!
  edges: [ConversationEdge]!
  aggregate: AggregateConversation!
}

input ConversationCreateInput {
  id: ID
  name: String
  texts: TextCreateManyWithoutConversationInput
  participants: UserCreateManyWithoutConversationsInput
}

input ConversationCreateManyWithoutParticipantsInput {
  create: [ConversationCreateWithoutParticipantsInput!]
  connect: [ConversationWhereUniqueInput!]
}

input ConversationCreateOneWithoutTextsInput {
  create: ConversationCreateWithoutTextsInput
  connect: ConversationWhereUniqueInput
}

input ConversationCreateWithoutParticipantsInput {
  id: ID
  name: String
  texts: TextCreateManyWithoutConversationInput
}

input ConversationCreateWithoutTextsInput {
  id: ID
  name: String
  participants: UserCreateManyWithoutConversationsInput
}

type ConversationEdge {
  node: Conversation!
  cursor: String!
}

enum ConversationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ConversationPreviousValues {
  id: ID!
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ConversationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ConversationScalarWhereInput!]
  OR: [ConversationScalarWhereInput!]
  NOT: [ConversationScalarWhereInput!]
}

type ConversationSubscriptionPayload {
  mutation: MutationType!
  node: Conversation
  updatedFields: [String!]
  previousValues: ConversationPreviousValues
}

input ConversationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConversationWhereInput
  AND: [ConversationSubscriptionWhereInput!]
  OR: [ConversationSubscriptionWhereInput!]
  NOT: [ConversationSubscriptionWhereInput!]
}

input ConversationUpdateInput {
  name: String
  texts: TextUpdateManyWithoutConversationInput
  participants: UserUpdateManyWithoutConversationsInput
}

input ConversationUpdateManyDataInput {
  name: String
}

input ConversationUpdateManyMutationInput {
  name: String
}

input ConversationUpdateManyWithoutParticipantsInput {
  create: [ConversationCreateWithoutParticipantsInput!]
  delete: [ConversationWhereUniqueInput!]
  connect: [ConversationWhereUniqueInput!]
  set: [ConversationWhereUniqueInput!]
  disconnect: [ConversationWhereUniqueInput!]
  update: [ConversationUpdateWithWhereUniqueWithoutParticipantsInput!]
  upsert: [ConversationUpsertWithWhereUniqueWithoutParticipantsInput!]
  deleteMany: [ConversationScalarWhereInput!]
  updateMany: [ConversationUpdateManyWithWhereNestedInput!]
}

input ConversationUpdateManyWithWhereNestedInput {
  where: ConversationScalarWhereInput!
  data: ConversationUpdateManyDataInput!
}

input ConversationUpdateOneRequiredWithoutTextsInput {
  create: ConversationCreateWithoutTextsInput
  update: ConversationUpdateWithoutTextsDataInput
  upsert: ConversationUpsertWithoutTextsInput
  connect: ConversationWhereUniqueInput
}

input ConversationUpdateWithoutParticipantsDataInput {
  name: String
  texts: TextUpdateManyWithoutConversationInput
}

input ConversationUpdateWithoutTextsDataInput {
  name: String
  participants: UserUpdateManyWithoutConversationsInput
}

input ConversationUpdateWithWhereUniqueWithoutParticipantsInput {
  where: ConversationWhereUniqueInput!
  data: ConversationUpdateWithoutParticipantsDataInput!
}

input ConversationUpsertWithoutTextsInput {
  update: ConversationUpdateWithoutTextsDataInput!
  create: ConversationCreateWithoutTextsInput!
}

input ConversationUpsertWithWhereUniqueWithoutParticipantsInput {
  where: ConversationWhereUniqueInput!
  update: ConversationUpdateWithoutParticipantsDataInput!
  create: ConversationCreateWithoutParticipantsInput!
}

input ConversationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  texts_every: TextWhereInput
  texts_some: TextWhereInput
  texts_none: TextWhereInput
  participants_every: UserWhereInput
  participants_some: UserWhereInput
  participants_none: UserWhereInput
  AND: [ConversationWhereInput!]
  OR: [ConversationWhereInput!]
  NOT: [ConversationWhereInput!]
}

input ConversationWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Mutation {
  createAlert(data: AlertCreateInput!): Alert!
  updateAlert(data: AlertUpdateInput!, where: AlertWhereUniqueInput!): Alert
  updateManyAlerts(data: AlertUpdateManyMutationInput!, where: AlertWhereInput): BatchPayload!
  upsertAlert(where: AlertWhereUniqueInput!, create: AlertCreateInput!, update: AlertUpdateInput!): Alert!
  deleteAlert(where: AlertWhereUniqueInput!): Alert
  deleteManyAlerts(where: AlertWhereInput): BatchPayload!
  createConversation(data: ConversationCreateInput!): Conversation!
  updateConversation(data: ConversationUpdateInput!, where: ConversationWhereUniqueInput!): Conversation
  updateManyConversations(data: ConversationUpdateManyMutationInput!, where: ConversationWhereInput): BatchPayload!
  upsertConversation(where: ConversationWhereUniqueInput!, create: ConversationCreateInput!, update: ConversationUpdateInput!): Conversation!
  deleteConversation(where: ConversationWhereUniqueInput!): Conversation
  deleteManyConversations(where: ConversationWhereInput): BatchPayload!
  createText(data: TextCreateInput!): Text!
  updateText(data: TextUpdateInput!, where: TextWhereUniqueInput!): Text
  updateManyTexts(data: TextUpdateManyMutationInput!, where: TextWhereInput): BatchPayload!
  upsertText(where: TextWhereUniqueInput!, create: TextCreateInput!, update: TextUpdateInput!): Text!
  deleteText(where: TextWhereUniqueInput!): Text
  deleteManyTexts(where: TextWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  alert(where: AlertWhereUniqueInput!): Alert
  alerts(where: AlertWhereInput, orderBy: AlertOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Alert]!
  alertsConnection(where: AlertWhereInput, orderBy: AlertOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AlertConnection!
  conversation(where: ConversationWhereUniqueInput!): Conversation
  conversations(where: ConversationWhereInput, orderBy: ConversationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Conversation]!
  conversationsConnection(where: ConversationWhereInput, orderBy: ConversationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConversationConnection!
  text(where: TextWhereUniqueInput!): Text
  texts(where: TextWhereInput, orderBy: TextOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Text]!
  textsConnection(where: TextWhereInput, orderBy: TextOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TextConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  alert(where: AlertSubscriptionWhereInput): AlertSubscriptionPayload
  conversation(where: ConversationSubscriptionWhereInput): ConversationSubscriptionPayload
  text(where: TextSubscriptionWhereInput): TextSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Text {
  id: ID!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  author: User!
  conversation: Conversation!
}

type TextConnection {
  pageInfo: PageInfo!
  edges: [TextEdge]!
  aggregate: AggregateText!
}

input TextCreateInput {
  id: ID
  text: String!
  author: UserCreateOneInput!
  conversation: ConversationCreateOneWithoutTextsInput!
}

input TextCreateManyWithoutConversationInput {
  create: [TextCreateWithoutConversationInput!]
  connect: [TextWhereUniqueInput!]
}

input TextCreateWithoutConversationInput {
  id: ID
  text: String!
  author: UserCreateOneInput!
}

type TextEdge {
  node: Text!
  cursor: String!
}

enum TextOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TextPreviousValues {
  id: ID!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TextScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TextScalarWhereInput!]
  OR: [TextScalarWhereInput!]
  NOT: [TextScalarWhereInput!]
}

type TextSubscriptionPayload {
  mutation: MutationType!
  node: Text
  updatedFields: [String!]
  previousValues: TextPreviousValues
}

input TextSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TextWhereInput
  AND: [TextSubscriptionWhereInput!]
  OR: [TextSubscriptionWhereInput!]
  NOT: [TextSubscriptionWhereInput!]
}

input TextUpdateInput {
  text: String
  author: UserUpdateOneRequiredInput
  conversation: ConversationUpdateOneRequiredWithoutTextsInput
}

input TextUpdateManyDataInput {
  text: String
}

input TextUpdateManyMutationInput {
  text: String
}

input TextUpdateManyWithoutConversationInput {
  create: [TextCreateWithoutConversationInput!]
  delete: [TextWhereUniqueInput!]
  connect: [TextWhereUniqueInput!]
  set: [TextWhereUniqueInput!]
  disconnect: [TextWhereUniqueInput!]
  update: [TextUpdateWithWhereUniqueWithoutConversationInput!]
  upsert: [TextUpsertWithWhereUniqueWithoutConversationInput!]
  deleteMany: [TextScalarWhereInput!]
  updateMany: [TextUpdateManyWithWhereNestedInput!]
}

input TextUpdateManyWithWhereNestedInput {
  where: TextScalarWhereInput!
  data: TextUpdateManyDataInput!
}

input TextUpdateWithoutConversationDataInput {
  text: String
  author: UserUpdateOneRequiredInput
}

input TextUpdateWithWhereUniqueWithoutConversationInput {
  where: TextWhereUniqueInput!
  data: TextUpdateWithoutConversationDataInput!
}

input TextUpsertWithWhereUniqueWithoutConversationInput {
  where: TextWhereUniqueInput!
  update: TextUpdateWithoutConversationDataInput!
  create: TextCreateWithoutConversationInput!
}

input TextWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  author: UserWhereInput
  conversation: ConversationWhereInput
  AND: [TextWhereInput!]
  OR: [TextWhereInput!]
  NOT: [TextWhereInput!]
}

input TextWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  username: String!
  name: String
  emirateId: String
  medicalRecord: String
  medicalLicense: String
  hospital: String
  address: String
  mobile: String
  createdAt: DateTime!
  updatedAt: DateTime!
  conversations(where: ConversationWhereInput, orderBy: ConversationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Conversation!]
  reports: Int
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  name: String
  emirateId: String
  medicalRecord: String
  medicalLicense: String
  hospital: String
  address: String
  mobile: String
  conversations: ConversationCreateManyWithoutParticipantsInput
  reports: Int
}

input UserCreateManyWithoutConversationsInput {
  create: [UserCreateWithoutConversationsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutConversationsInput {
  id: ID
  username: String!
  name: String
  emirateId: String
  medicalRecord: String
  medicalLicense: String
  hospital: String
  address: String
  mobile: String
  reports: Int
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  name_ASC
  name_DESC
  emirateId_ASC
  emirateId_DESC
  medicalRecord_ASC
  medicalRecord_DESC
  medicalLicense_ASC
  medicalLicense_DESC
  hospital_ASC
  hospital_DESC
  address_ASC
  address_DESC
  mobile_ASC
  mobile_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  reports_ASC
  reports_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  name: String
  emirateId: String
  medicalRecord: String
  medicalLicense: String
  hospital: String
  address: String
  mobile: String
  createdAt: DateTime!
  updatedAt: DateTime!
  reports: Int
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  emirateId: String
  emirateId_not: String
  emirateId_in: [String!]
  emirateId_not_in: [String!]
  emirateId_lt: String
  emirateId_lte: String
  emirateId_gt: String
  emirateId_gte: String
  emirateId_contains: String
  emirateId_not_contains: String
  emirateId_starts_with: String
  emirateId_not_starts_with: String
  emirateId_ends_with: String
  emirateId_not_ends_with: String
  medicalRecord: String
  medicalRecord_not: String
  medicalRecord_in: [String!]
  medicalRecord_not_in: [String!]
  medicalRecord_lt: String
  medicalRecord_lte: String
  medicalRecord_gt: String
  medicalRecord_gte: String
  medicalRecord_contains: String
  medicalRecord_not_contains: String
  medicalRecord_starts_with: String
  medicalRecord_not_starts_with: String
  medicalRecord_ends_with: String
  medicalRecord_not_ends_with: String
  medicalLicense: String
  medicalLicense_not: String
  medicalLicense_in: [String!]
  medicalLicense_not_in: [String!]
  medicalLicense_lt: String
  medicalLicense_lte: String
  medicalLicense_gt: String
  medicalLicense_gte: String
  medicalLicense_contains: String
  medicalLicense_not_contains: String
  medicalLicense_starts_with: String
  medicalLicense_not_starts_with: String
  medicalLicense_ends_with: String
  medicalLicense_not_ends_with: String
  hospital: String
  hospital_not: String
  hospital_in: [String!]
  hospital_not_in: [String!]
  hospital_lt: String
  hospital_lte: String
  hospital_gt: String
  hospital_gte: String
  hospital_contains: String
  hospital_not_contains: String
  hospital_starts_with: String
  hospital_not_starts_with: String
  hospital_ends_with: String
  hospital_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  reports: Int
  reports_not: Int
  reports_in: [Int!]
  reports_not_in: [Int!]
  reports_lt: Int
  reports_lte: Int
  reports_gt: Int
  reports_gte: Int
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  username: String
  name: String
  emirateId: String
  medicalRecord: String
  medicalLicense: String
  hospital: String
  address: String
  mobile: String
  conversations: ConversationUpdateManyWithoutParticipantsInput
  reports: Int
}

input UserUpdateInput {
  username: String
  name: String
  emirateId: String
  medicalRecord: String
  medicalLicense: String
  hospital: String
  address: String
  mobile: String
  conversations: ConversationUpdateManyWithoutParticipantsInput
  reports: Int
}

input UserUpdateManyDataInput {
  username: String
  name: String
  emirateId: String
  medicalRecord: String
  medicalLicense: String
  hospital: String
  address: String
  mobile: String
  reports: Int
}

input UserUpdateManyMutationInput {
  username: String
  name: String
  emirateId: String
  medicalRecord: String
  medicalLicense: String
  hospital: String
  address: String
  mobile: String
  reports: Int
}

input UserUpdateManyWithoutConversationsInput {
  create: [UserCreateWithoutConversationsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutConversationsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutConversationsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutConversationsDataInput {
  username: String
  name: String
  emirateId: String
  medicalRecord: String
  medicalLicense: String
  hospital: String
  address: String
  mobile: String
  reports: Int
}

input UserUpdateWithWhereUniqueWithoutConversationsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutConversationsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutConversationsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutConversationsDataInput!
  create: UserCreateWithoutConversationsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  emirateId: String
  emirateId_not: String
  emirateId_in: [String!]
  emirateId_not_in: [String!]
  emirateId_lt: String
  emirateId_lte: String
  emirateId_gt: String
  emirateId_gte: String
  emirateId_contains: String
  emirateId_not_contains: String
  emirateId_starts_with: String
  emirateId_not_starts_with: String
  emirateId_ends_with: String
  emirateId_not_ends_with: String
  medicalRecord: String
  medicalRecord_not: String
  medicalRecord_in: [String!]
  medicalRecord_not_in: [String!]
  medicalRecord_lt: String
  medicalRecord_lte: String
  medicalRecord_gt: String
  medicalRecord_gte: String
  medicalRecord_contains: String
  medicalRecord_not_contains: String
  medicalRecord_starts_with: String
  medicalRecord_not_starts_with: String
  medicalRecord_ends_with: String
  medicalRecord_not_ends_with: String
  medicalLicense: String
  medicalLicense_not: String
  medicalLicense_in: [String!]
  medicalLicense_not_in: [String!]
  medicalLicense_lt: String
  medicalLicense_lte: String
  medicalLicense_gt: String
  medicalLicense_gte: String
  medicalLicense_contains: String
  medicalLicense_not_contains: String
  medicalLicense_starts_with: String
  medicalLicense_not_starts_with: String
  medicalLicense_ends_with: String
  medicalLicense_not_ends_with: String
  hospital: String
  hospital_not: String
  hospital_in: [String!]
  hospital_not_in: [String!]
  hospital_lt: String
  hospital_lte: String
  hospital_gt: String
  hospital_gte: String
  hospital_contains: String
  hospital_not_contains: String
  hospital_starts_with: String
  hospital_not_starts_with: String
  hospital_ends_with: String
  hospital_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  conversations_every: ConversationWhereInput
  conversations_some: ConversationWhereInput
  conversations_none: ConversationWhereInput
  reports: Int
  reports_not: Int
  reports_in: [Int!]
  reports_not_in: [Int!]
  reports_lt: Int
  reports_lte: Int
  reports_gt: Int
  reports_gte: Int
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
}
